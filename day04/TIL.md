## 학습 날짜

* 2020-11-25

## 학습 내용

### 구성 요소 활성화

액티비티, 서비스, Broadcast Receiver는 인텐트라는 비동기식 메시지로 활성화됩니다. 인텐트는 런타임에서 각 구성 요소를 서로 바인딩합니다. 즉 구성 요소가 어느 앱에 속하든 관계없이 다른 구성요소로부터 작업을 요청하는 역할을 합니다.

인텐트는 Intent 객체로 생성되며, 이것이 특정 구성 요소(명시적 인텐트)를 활성화할지 아니면 구성 요소의 특정 유형(암시적 인텐트)를 활성화할지 나타내는 메시지를 정의합니다.

액티비티와 서비스의 경우, 인텐트는 수행할 작업을 정의하며, 시작되는 구성 요소가 알아야 할 것이 많이 있기는 하지만 그 중에서도 작업을 수행할 데이터의 URI를 지정할 수 있습니다. 예를 들어 인텐트는 액티비티에 이미지를 표시하거나 웹 페이지를 열라는 요청을 전달할 수 있습니다. 경우에 따라 결과를 수신하기 위해 액티비티를 시작할 수 있습니다. 이 경우, 액티비티도 Intent에서 결과를 반환합니다.

Broadcast Receiver의 경우, 인텐트는 단순히 브로드캐스트될 알림을 정의합니다.

콘텐츠 제공자는 인텐트로 활성화되지 않습니다. ContentResolver가 보낸 요청의 대상으로 지정되면 활성화됩니다. 콘텐츠 확인자는 콘텐츠 제공자와의 모든 직접적인 트랜잭션을 처리하여 제공자와의 트랜잭션을 수행하는 구성 요소가 그런 처리를 하지 않는 대신 ContentResolver 객체에서 메서드를 호출하게 합니다. 이렇게 되면 콘텐츠 제공자와 정보를 요청하는 구성 요소 사이에 추상화 계층이 하나 남습니다(보안 목적)

각 유형의 구성 요소를 활성화하는 데는 각기 별도의 메서드가 있습니다.

- 액티비티
	- Intent를 startActivity() 또는 startActivityForResult()에 전달(액티비티가 결과를 반환하기를 원하는 경우)
- 서비스
	- 5.0 이상에선 JobScheduler 클래스를 사용하여 작업을 예약할 수 있음
	- 초기 버전의 경우 Intent를 startService()에 전달하여 서비스를 시작(또는 진행 중인 서비스에 새로운 지침을 전달)
	- bindService()에 전달하여 서비스에 바인딩할 수도 있음
- Broadcast Receiver
	- sendBroadcast(), sendOrderBroadcast(), 또는 sendStickyBoradcast()와 같은 메서드에 Intent를 전달하여 브로드캐스트를 시작
- 콘텐츠 제공자
	- ContentResolver에서 query()를 호출

### 매니페스트 파일

Android 시스템이 앱 구성 요소를 시작하려면 시스템은 우선 앱의 메니페스트 파일, AndroidManifest.xml을 읽어서 해당 구성 요소가 존재하는지 확인합니다. 앱은 이 파일 안에 모든 구성 요소를 선언해야 하며, 이 파일은 앱 프로젝트 디렉토리의 루트에 있어야 합니다.

매니페스트는 앱의 구성 요소를 선언하는 것 이외에도 많은 역할을 합니다.

- 앱이 요구하는 모든 사용자 권한을 식별(인터넷 액세스, 연락처에 댛나 읽기 액세스 등등)
- 앱이 어느 API를 사용하는지를 근거로 앱에서 요구하는 최소 API 레벨을 선언
- 앱에서 사용하거나 요구하는 하드웨어 및 소프트웨어 기능(카메라, 블루투스 서비스, 멀티터치 등등)을 선언
- 앱이 링크되어야 하는 API 라이브러리를 선언(Android 프레임워크 API 제외)

#### 구성 요소 선언

매니페스트의 주요 작업은 시스템에 앱의 구성 요소에 대해 알리는 것입니다. 예를 들어 매니페스트 파일은 액티비티를 다음과 같이 선언할 수 있습니다.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>
```

```<application>``` 요소에서 android:icon 특성은 앱을 식별하는 아이콘에 대한 리소스를 가리킵니다.

```<activity>``` 요소에서는 android:name 특성이 Activity 하위 클래스의 완전히 정규화된 클래스 이름을 나타내며 android:label 특성은 액티비티의 사용자에게 표시되는 레이블로 사용할 문자열을 나타냅니다.

다음 요소를 사용하여 모든 앱 구성 요소를 선언해야 합니다.

- 액티비티의 경우 ```<activity>``` 요소
- 서비스의 경우 ```<service>``` 요소
- Broadcast Receiver의 경우 ```<receiver>``` 요소
- 콘텐츠 제공자의 경우 ```<provider>``` 요소

소스에는 포함시키지만 매니페스트에서는 선언하지 않는 액티비티, 서비스, 콘텐츠 제공자는 시스템에 표시되지 않으며, 따라서 실행될 수 없습니다.
Broadcast Receiver는 매니페스트에서 선언해도 되고 코드를 사용해(BroadcastReceiver 객체로) 동적으로 생성한 다음 시스템에 등록해도 됩니다. 이때 registerReceiver()를 호출하는 방법을 사용합니다.

#### 구성 요소 기능 선언

활성화 상태의 구성 요소에서는 Intent를 사용하여 액티비티, 서비스 및 Broadcast Receiver를 시작할 수 있습니다. 그렇게 하려면 Intent를 사용하여 대상 구성 요소를 인텐트 내에서 명시적으로 명명하면 됩니다(구성 요소 클래스 이름을 사용).
암시적 인텐트는 수행할 작업의 유형을 설명하고, 원한다면 작업ㅇ르 수행할 대상은 데이터를 설명할 수도 있습니다. 암시적 인텐트를 사용하면 시스템이 작업을 수행할 수 있는 기기에서 구성 요소를 찾아서 작업을 시작할 수 있습니다. 인텐트가 설명한 작업을 수행할 수 있는 구성 요소가 여러 개인 경우, 어느 것을 사용할지는 사용자가 선택합니다.

**주의사항**

인텐트를 사용하여 Service에 바인딩할 경우에는 명시적 인텐트로 앱을 보호해야 합니다. 암시적 인텐트를 사용하여 서비스를 시작하면 보안 위험을 초래합니다. 인텐트에 어느 서비스가 응답할 것인지 확신할 수 없고 사용자는 어느 서비스가 시작되는지 볼 수 없기 때문입니다. 5.0부터 시스템은 개발자가 암시적 인텐트로 bindService()를 호출하면 예외를 발생시킵니다. 서비스에 대해 인텐트 필터를 선언하지 마세요

시스템은 기기에 설치된 다른 앱의 매니페스트 파일에 제공된 인텐트 필터와 수신된 인텐트를 비교하는 방법으로 인텐트에 응답할 수 있는 구성 요소를 식별합니다.

앱의 매니페스트에서 액티비티를 선언하는 경우, 선택적으로 해당 액티비티의 기능을 선언하는 인텐트 필터를 포함시켜서 다른 앱으로부터의 인텐트에 응답하게 할 수 있습니다. ```<intent-filter>``` 요소를 해당 구성 요소의 선언 요소에 대한 하위 요소로 추가하면 구성 요소에 대한 인텐트 필터를 선언할 수 있습니다.

새 이메일을 작성하는 액티비티가 포함된 이메일 앱을 빌드한다고 가정할 때, send 인텐트에 응답하는 인텐트 필터를 선언하려면 다음과 같이 작성합니다.
```xml
<manifest ... >
    ...
    <application ... >
        <activity android:name="com.example.project.ComposeEmailActivity">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <data android:type="*/*" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

다른 앱이 ACTION_SEND 작업이 포함된 인텐트를 생성하고 이를 startActivity()로 전달하면 사용자가 이메일 초안을 작성하고 이를 전송할 수 있는 액티비티를 시작할 수 있습니다.

#### 앱 요구사항 선언

앱에 필요한 기능이 없는 기기에 앱을 설치하는 불상사를 방지하려면, 앱이 지원하는 기기 유형에 대한 프로필을 명확하게 정의하는 것이 중요합니다. 그러려면 매니페스트 파일에 기기와 소프트웨어 요구사항을 선언하면 됩니다. 이와 같은 선언은 대부분 정보성일 뿐이며 시스템은 이를 읽지 않는 것이 일반적이지만, Google Play와 같은 외부 서비스는 사용자가 본인의 기기에서 앱을 검색할 때 필터링을 제공하기 위해 이와 같은 선언도 읽습니다.

예를 들어 앱에 카메라가 필요하고 Android 2.1(API 레벨 7)에 도입된 API를 사용하는 경우, 이와 같은 내용을 매니페스트 파일에 요구사항으로 선언하려면 다음과 같습니다.


```xml
<manifest ... >
    <uses-feature android:name="android.hardware.camera.any"
                  android:required="true" />
    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="19" />
    ...
</manifest>
```

### 앱 리소스

앱 리소스를 사용하면 코드를 수정하지 않고 앱의 다양한 특성을 쉽게 업데이트할 수 있습니다. 일련의 대체 리소스를 제공함으로써 다양한 기기 구성에 맞게 앱을 최적화할 수도 있습니다.

Android 프로젝트에 포함하는 리소스마다 SDK 빌드 도구가 고유한 정수 ID를 정의하므로, 이를 사용하여 앱 코드에서의 리소스나 XML로 정의된 다른 리소스에서 참조할 수 있습니다. 예를 들어 앱에 logo.png 라는 이름의 이미지 파일이 들어 있다면(res/drawable/ 디렉토리에 저장), SDK 도구가 R.drawable.logo 라는 리소스 ID를 생성합니다. 이것을 사용하여 이미지를 참조하고 사용자 인터페이스에 삽입할 수 있습니다. 이 ID는 각 앱의 정수로 매핑되며, 이것을 사용하여 이미지를 참조할 수도 있고 이것을 사용자 인터페이스에 삽입할 수도 있습니다.

소스 코드와 별개로 리소스를 제공하는 것의 가장 중요한 측면 중 하나는 여러 가지 기기 구성에 맞게 대체 리소스를 제공할 능력을 갖추게 된다는 점입니다. 예를 들어 UI문자열을 XML로 정의하면 이러한 문자열을 다른 언어로 번역한 뒤 해당 문자열을 별개의 파일에 저장할 수 있습니다. 그러면 Android가 리소스 디렉토리 이름에 추가하는 언어 한정자 및 사용자의 언어 설정을 기반으로 적절한 언어 문자열을 UI에 적용합니다.

